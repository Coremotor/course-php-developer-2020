Описание
Домашнее задание состоит из нескольких отдельных, не связанных между собой задач. Каждое задание делается в отдельном файле с уникальным пространством имен.


Ферма — абстракция

1. Описать следующие классы:

Cow — Коровка;

Pig — Хрюшка;

Chicken — Курица;

Farm — Ферма.

Ферма должна содержать свойство public $animals — массив с животными, а также метод public function addAnimal(Animal $animal), который добавит животное на ферму.

Каждое животное умеет говорить public function say() и ходить public function walk()

2. Создать и реализовать эти методы: 

метод say() — должен выводить голос каждого животного;

метод walk() — должен выводить "топ-топ" для каждого из животных.

При заселении на ферму животное должно пойти.

3. Создать метод перекличка на ферме public function rollCall(), в котором каждое животное на ферме покажет свой голос в случайном порядке.

4. Создать класс — абстракцию для данной задачи. Следует обратить внимание на условие в этой задаче — волей-неволей эта абстракция в явном виде присутствует в условии задачи.

5. Вынести как можно больше функционала в абстракцию, а реализации сделать наследниками этой абстракции.

6. Поселить корову, двух хрюшек и курицу на ферму. Провести их перекличку.

Ферма 2.0

Добавить к созданным в предыдущем задании следующие классы:

Goose — Гусь;

Turkey — Индюк;

Horse — Лошадь;

BirdFarm — Птичья ферма;

Farmer — фермер.

Теперь у вас есть две фермы: одна будет для птиц, другая для животных с копытцами (hoof).

7. Создать дополнительные уровни абстракции для животных (копытные и птицы). При этом птицы при ходьбе должны пытаться взлететь, а не топать, как другие животные. У них должен быть метод function tryToFly(), который выводит "Вжих-вжих-топ-топ". 

8. Скорректировать наследования всех животных на более точные, и реализовать недостающие методы.
На птицеферме у нас строгий учет свободных мест, поэтому сразу после заселения туда новой птицы, Ферма должна сообщать суммарное количество птиц на ней. Для этого необходимо добавить метод function showAnimalsCount(), выводящий на экран "Птиц на ферме: <кол-во птиц>".

9. За расселение животных и учет на фермах теперь частично отвечает фермер. Добавить фермеру методы:

function addAnimal(Farm $farm, Animal $animal) — метод должен заселить на ферму животное;

function rollCall(Farm $farm) — метод должен вызывать перекличку на ферме.

10. Создать объекты: фермер, ферма, птицеферма.

11. Создать в указанном порядке и приказать фермеру заселить следующих животных: корову, 2-х хрюшек, курицу, 3-х индеек, двух лошадок и гуся. После этого заставьте лентяя-фермера устроить перекличку всех животных на обеих фермах.



Черный ящик – Инкапсуляция
1. Создать классы:

BlackBox — черный ящик, у него должно быть закрытое от всех свойство private $data;

Plane — самолет, должен содержать закрытое свойство private $blackBox. В конструкторе это свойство должно быть проинициализировано новым классом BlackBox;

Engineer — Инженер-дешифровщик черных ящиков.

Класс BlackBox содержит следующие методы:

public function addLog($message) — добавляет очередную строку в свое свойство $data;

public function getDataByEngineer(Engineer $engineer) — возвращает свои данные для инженера.

Класс Plane должен содержать методы: 

public function flyAndCrush()
{
$this->flyProcess();
$this->crushProcess();
    }, где flyProcess — процесс полета может иначе проходить для других самолетов, пишет лог в черный ящик, придумайте что будет записано в этом методе в черный ящик, а crushProcess — процесс крушения переопределен быть не может, пишет лог в черный ящик. Нужно придумать, что будет записано в этом методе в черный ящик;

protected function addLog($message) — передает сообщение для записи в лог черного ящика;

public function getBoxForEngineer(Engineer $engineer)
{
$engineer->setBox($this->blackBox);
    }

2. Реализовать класс Engineer:

public function setBox(BlackBox $blackBox) — устанавливает черный ящик для дешифрации у инженера;

public function takeBox(Plane $plane) — должен доставать черный ящик из самолета (нужно посмотреть, какой подходящий метод есть в классе Plane);

public function decodeBox() — декодирует черный ящик — выводит на экран лог черного ящика.

3. Реализовать методы без изменения области видимости методов и свойств.

4. Создать самолет, устроить ему полет с крушением.

5. Создать инженера, взять черный ящик из упавшего самолета и дешифровать его.

6. Создать новый вид самолета (наследоваться следует от Plane). Самолет должен вести другой лог во время полета. Но, к сожалению, путь его тот же, что и для предыдущего самолета. Дешифровать и его лог.



Домна – полиморфизм
Была, кажется, такая игра: в печи нужно было сжигать вещи, и чем лучше это все горит, тем больше дают очков. Нужно сделать небольшую часть этой игры.

1. Создать следующие классы:

Forge — печь, должен содержать один метод:

public function burn($object)
{
$flame = $object->burn();
echo $flame->render((string)$object) . PHP_EOL;
    };

BlueFlame, RedFlame, Smoke — голубое пламя, красное пламя и дым, должны содержать один метод: public function render($name), возвращающий текст (каждый класс со своим текстом), например, для класса Smoke:
public function render($name)
{
return $name . " лишь задымился";
    }

2. Создать не менее 5 различных классов, которые будут сжигаться в печи. Каждый класс должен реализовывать два метода:

public function burn() — должен возвращать один из объектов: BlueFlame, RedFlame, Smoke — на ваш выбор;

public function __toString() — должен возвращать строку-название текущего объекта.

3. Придумать никак не связанные между собой объекты, например, пианино и больная голова, чтобы ощутить именно эффект полиморфизма, а не наследования. :)

4. Создать печь и сжечь в ней свои объекты. 

А затем создать новый класс по той же схеме и насладиться мощью полиморфизма, спалив его экземпляр в печи. :)